'use strict';

require('isomorphic-unfetch');
var qs = require('qs');
var set = require('lodash/set');
var get = require('lodash/get');
var uniq = require('lodash/uniq');
var find = require('lodash/find');
var round = require('lodash/round');
var findIndex = require('lodash/findIndex');
var camelCase = require('lodash/camelCase');
var snakeCase = require('lodash/snakeCase');
var cloneDeep = require('lodash/cloneDeep');
var isEqual = require('lodash/isEqual');
var deepmerge = require('deepmerge');
var objectKeysNormalizer = require('object-keys-normalizer');
var toLower = require('lodash/toLower');
var reduce$1 = require('lodash/reduce');
var isEmpty = require('lodash/isEmpty');
var map$1 = require('lodash/map');
var toNumber = require('lodash/toNumber');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var set__default = /*#__PURE__*/_interopDefaultLegacy(set);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var uniq__default = /*#__PURE__*/_interopDefaultLegacy(uniq);
var find__default = /*#__PURE__*/_interopDefaultLegacy(find);
var round__default = /*#__PURE__*/_interopDefaultLegacy(round);
var findIndex__default = /*#__PURE__*/_interopDefaultLegacy(findIndex);
var camelCase__default = /*#__PURE__*/_interopDefaultLegacy(camelCase);
var snakeCase__default = /*#__PURE__*/_interopDefaultLegacy(snakeCase);
var cloneDeep__default = /*#__PURE__*/_interopDefaultLegacy(cloneDeep);
var isEqual__default = /*#__PURE__*/_interopDefaultLegacy(isEqual);
var deepmerge__default = /*#__PURE__*/_interopDefaultLegacy(deepmerge);
var toLower__default = /*#__PURE__*/_interopDefaultLegacy(toLower);
var reduce__default = /*#__PURE__*/_interopDefaultLegacy(reduce$1);
var isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(isEmpty);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map$1);
var toNumber__default = /*#__PURE__*/_interopDefaultLegacy(toNumber);

let options$2 = {};
function merge(x, y, opt = {}) {
  if (!y || typeof y !== "object") {
    return x;
  }
  if (!x || typeof x !== "object") {
    return x;
  }
  function arrayMerge(target, source, options2) {
    const destination = target.slice();
    source.forEach((item, index) => {
      if (typeof destination[index] === "undefined") {
        destination[index] = options2.cloneUnlessOtherwiseSpecified(
          item,
          options2
        );
      } else if (options2.isMergeableObject(item)) {
        destination[index] = merge(target[index], item, options2);
      } else if (target.indexOf(item) === -1) {
        destination.push(item);
      }
    });
    return destination;
  }
  return deepmerge__default["default"](x, y, {
    arrayMerge
  });
}
function setOptions(optns) {
  options$2 = optns;
}
function getOptions() {
  return options$2;
}
function isObject(val) {
  return val && typeof val === "object" && !(val instanceof Array);
}
function toCamel(obj) {
  if (!obj)
    return obj;
  const objCopy = JSON.parse(JSON.stringify(obj));
  return objectKeysNormalizer.normalizeKeys(objCopy, keyToCamel);
}
function toCamelPath(str) {
  if (typeof str === "string") {
    return str.split(".").map(camelCase__default["default"]).join(".");
  }
  return str;
}
function toSnake(obj) {
  if (!obj)
    return obj;
  const objCopy = JSON.parse(JSON.stringify(obj));
  return objectKeysNormalizer.normalizeKeys(objCopy, keyToSnake);
}
function keyToSnake(key) {
  return (key[0] === "$" ? "$" : "") + snakeCase__default["default"](key).replace(/\_([0-9])/g, "$1");
}
function keyToCamel(key) {
  return (key[0] === "$" ? "$" : "") + camelCase__default["default"](key).replace(/\_([0-9])/g, "$1");
}
function trimBoth(str) {
  return trimStart(trimEnd(str));
}
function trimStart(str) {
  return typeof str === "string" ? str.replace(/^[/]+/, "") : "";
}
function trimEnd(str) {
  return typeof str === "string" ? str.replace(/[/]+$/, "") : "";
}
function stringifyQuery(str) {
  return qs.stringify(str);
}
function map(arr, cb) {
  return arr instanceof Array ? arr.map(cb) : [];
}
function reduce(arr, cb, init) {
  return arr instanceof Array ? arr.reduce(cb, init) : init;
}
function isServer() {
  return !(typeof window !== "undefined" && window && window.document);
}
function isFunction(func) {
  return typeof func === "function";
}
function defaultMethods(request, uri, methods) {
  return {
    list: methods.indexOf("list") >= 0 ? function(query) {
      return request("get", uri, void 0, query);
    } : void 0,
    get: methods.indexOf("get") >= 0 ? function(id, query) {
      return request("get", uri, id, query);
    } : void 0
  };
}
async function vaultRequest(method, url, data, opt = void 0) {
  const vaultUrl = options$2.vaultUrl;
  const timeout = options$2.timeout;
  const requestId = vaultRequestId();
  const callback = `swell_vault_response_${requestId}`;
  data = {
    $jsonp: {
      method,
      callback
    },
    $data: data,
    $key: options$2.key
  };
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.type = "text/javascript";
    script.src = `${trimEnd(vaultUrl)}/${trimStart(url)}?${serializeData(
      data
    )}`;
    const errorTimeout = setTimeout(() => {
      window[callback]({
        $error: `Request timed out after ${timeout / 1e3} seconds`,
        $status: 500
      });
    }, timeout);
    window[callback] = (result) => {
      clearTimeout(errorTimeout);
      if (result && result.$error) {
        const err = new Error(result.$error);
        err.code = "request_error";
        err.status = result.$status;
        reject(err);
      } else if (!result || result.$status >= 300) {
        const err = new Error(
          "A connection error occurred while making the request"
        );
        err.code = "connection_error";
        err.status = result.$status;
        reject(err);
      } else {
        resolve(options$2.useCamelCase ? toCamel(result.$data) : result.$data);
      }
      delete window[callback];
      script.parentNode.removeChild(script);
    };
    document.getElementsByTagName("head")[0].appendChild(script);
  });
}
function vaultRequestId() {
  window.__swell_vault_request_id = window.__swell_vault_request_id || 0;
  window.__swell_vault_request_id++;
  return window.__swell_vault_request_id;
}
function serializeData(data) {
  const s = [];
  const add = function(key2, value) {
    if (typeof value === "function") {
      value = value();
    } else if (value == null) {
      value = "";
    }
    s[s.length] = encodeURIComponent(key2) + "=" + encodeURIComponent(value);
  };
  for (const key2 in data) {
    buildParams(key2, data[key2], add);
  }
  return s.join("&").replace(" ", "+");
}
const rbracket = /\[\]$/;
function buildParams(key, obj, add) {
  let name;
  if (obj instanceof Array) {
    for (let i = 0; i < obj.length; i++) {
      if (rbracket.test(key)) {
        add(key, v);
      } else {
        buildParams(
          key + "[" + (typeof v === "object" && v != null ? i : "") + "]",
          v,
          add
        );
      }
    }
  } else if (obj && typeof obj === "object") {
    for (name in obj) {
      buildParams(key + "[" + name + "]", obj[name], add);
    }
  } else {
    add(key, obj);
  }
}
function base64Encode(string) {
  if (typeof btoa !== "undefined") {
    return btoa(string);
  }
  return Buffer.from(string).toString("base64");
}
function getLocationParams(location) {
  const url = location.search;
  const query = url.substr(1);
  const result = {};
  query.split("&").forEach(function(part) {
    const item = part.split("=");
    result[item[0]] = decodeURIComponent(item[1]);
  });
  return result;
}
function removeUrlParams() {
  const url = window.location.origin + window.location.pathname;
  window.history.pushState({ path: url }, "", url);
}

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  defaultMethods: defaultMethods,
  set: set__default["default"],
  get: get__default["default"],
  uniq: uniq__default["default"],
  find: find__default["default"],
  round: round__default["default"],
  findIndex: findIndex__default["default"],
  camelCase: camelCase__default["default"],
  cloneDeep: cloneDeep__default["default"],
  merge: merge,
  setOptions: setOptions,
  getOptions: getOptions,
  toCamel: toCamel,
  toCamelPath: toCamelPath,
  toSnake: toSnake,
  trimBoth: trimBoth,
  trimStart: trimStart,
  trimEnd: trimEnd,
  stringifyQuery: stringifyQuery,
  isServer: isServer,
  isFunction: isFunction,
  isObject: isObject,
  isEqual: isEqual__default["default"],
  snakeCase: snakeCase__default["default"],
  map: map,
  reduce: reduce,
  base64Encode: base64Encode,
  vaultRequest: vaultRequest,
  getLocationParams: getLocationParams,
  removeUrlParams: removeUrlParams
});

const cardApi = {
  async createToken(data) {
    let error = null;
    let code = null;
    let param = null;
    if (!data) {
      error = "Card details are missing in `swell.card.createToken(card)`";
      param = "";
    }
    const card = toSnake(data);
    if (!card.nonce) {
      if (!this.validateNumber(card.number)) {
        error = "Card number appears to be invalid";
        code = "invalid_card_number";
        param = "number";
      }
      if (card.exp) {
        const exp = this.expiry(card.exp);
        card.exp_month = exp.month;
        card.exp_year = exp.year;
      }
      if (!this.validateExpiry(card.exp_month, card.exp_year)) {
        error = "Card expiry appears to be invalid";
        code = "invalid_card_expiry";
        param = "exp_month";
      }
      if (!this.validateCVC(card.cvc)) {
        error = "Card CVC code appears to be invalid";
        code = "invalid_card_cvc";
        param = "exp_cvc";
      }
    }
    if (error) {
      const err = new Error(error);
      err.code = code || "invalid_card";
      err.status = 402;
      err.param = param;
      throw err;
    }
    const result = await vaultRequest("post", "/tokens", card);
    if (result.errors) {
      const param2 = Object.keys(result.errors)[0];
      const err = new Error(result.errors[param2].message || "Unknown error");
      err.code = "vault_error";
      err.status = 402;
      err.param = param2;
      throw err;
    }
    return result;
  },
  expiry(value) {
    if (value && value.month && value.year) {
      return value;
    }
    const parts = new String(value).split(/[\s\/\-]+/, 2);
    const month = parts[0];
    let year = parts[1];
    if (year && year.length === 2 && /^\d+$/.test(year)) {
      const prefix = new Date().getFullYear().toString().substring(0, 2);
      year = prefix + year;
    }
    return {
      month: ~~month,
      year: ~~year
    };
  },
  types() {
    let e, t, n, r;
    t = {};
    for (e = n = 40; n <= 49; e = ++n)
      t[e] = "Visa";
    for (e = r = 50; r <= 59; e = ++r)
      t[e] = "MasterCard";
    return t[34] = t[37] = "American Express", t[60] = t[62] = t[64] = t[65] = "Discover", t[35] = "JCB", t[30] = t[36] = t[38] = t[39] = "Diners Club", t;
  },
  type(num) {
    return this.types()[num.slice(0, 2)] || "Unknown";
  },
  luhnCheck(num) {
    let t, n, r, i, s, o;
    r = true, i = 0, n = (num + "").split("").reverse();
    for (s = 0, o = n.length; s < o; s++) {
      t = n[s], t = parseInt(t, 10);
      if (r = !r)
        t *= 2;
      t > 9 && (t -= 9), i += t;
    }
    return i % 10 === 0;
  },
  validateNumber(num) {
    return num = (num + "").replace(/\s+|-/g, ""), num.length >= 10 && num.length <= 16 && this.luhnCheck(num);
  },
  validateExpiry(month, year) {
    let r, i;
    return month = String(month).trim(), year = String(year).trim(), /^\d+$/.test(month) ? /^\d+$/.test(year) ? parseInt(month, 10) <= 12 ? (i = new Date(year, month), r = new Date(), i.setMonth(i.getMonth() - 1), i.setMonth(i.getMonth() + 1, 1), i > r) : false : false : false;
  },
  validateCVC(val) {
    return val = String(val).trim(), /^\d+$/.test(val) && val.length >= 3 && val.length <= 4;
  }
};

var __defProp$9 = Object.defineProperty;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a, prop, b[prop]);
    }
  return a;
};
const COOKIE_MAX_AGE = 604800;
function getCookie(name) {
  if (isServer()) {
    return void 0;
  }
  const matches = document.cookie.match(
    new RegExp(
      "(?:^|; )" + name.replace(/([.$?*|{}()[]\\\/\+^])/g, "\\$1") + "=([^;]*)"
    )
  );
  return matches ? decodeURIComponent(matches[1]) : void 0;
}
function setCookie(name, value, options = {}) {
  if (isServer()) {
    return;
  }
  options = __spreadValues$9({
    path: "/",
    "max-age": COOKIE_MAX_AGE,
    samesite: "lax"
  }, options);
  if (options.expires && options.expires.toUTCString) {
    options.expires = options.expires.toUTCString();
  }
  let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);
  for (const optionKey in options) {
    updatedCookie += "; " + optionKey;
    const optionValue = options[optionKey];
    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }
  document.cookie = updatedCookie;
}

var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
const RECORD_TIMEOUT = 5e3;
let VALUES = {};
const cacheApi = {
  options: {
    enabled: true,
    debug: false
  },
  debug(...args) {
    if (this.options.debug) {
      console.log(...args);
    }
  },
  values({ model, id }, setValues = void 0) {
    this.debug("cache.values", ...arguments);
    if (setValues !== void 0) {
      for (let key in setValues) {
        set__default["default"](VALUES, `${model}.${id}.${key}`, setValues[key]);
      }
      return;
    }
    return get__default["default"](VALUES, `${model}.${id}`, {});
  },
  preset(details) {
    this.debug("cache.preset", ...arguments);
    const { presets = [] } = this.values(details);
    presets.push(details);
    this.values(details, { presets });
  },
  set(details) {
    this.debug("cache.set", ...arguments);
    let { model, id, path, value } = details;
    let { data = {}, record, presets } = this.values(details);
    if (id === null) {
      return;
    }
    if (record === void 0) {
      return this.preset(details);
    }
    data = merge(record || {}, data);
    const { useCamelCase } = getOptions();
    if (useCamelCase && value && typeof value === "object") {
      value = toCamel(value);
    }
    if (path || value instanceof Array) {
      let upData = __spreadValues$8({}, data || {});
      let upPath = useCamelCase ? toCamelPath(path) : path;
      set__default["default"](upData, upPath || "", value);
      data = upData;
    } else if (value && typeof value === "object") {
      data = data || {};
      data = merge(data, value);
    } else {
      data = value;
    }
    this.values(details, { data });
    try {
      const cache = VALUES[model][id];
      if (cache !== void 0) {
        if (cache.data !== void 0) {
          cache.data = JSON.parse(JSON.stringify(cache.data));
        }
        if (cache.record !== void 0) {
          cache.record = JSON.parse(JSON.stringify(cache.record));
        }
      }
    } catch (err) {
    }
  },
  get(model, id) {
    this.debug("cache.get", ...arguments);
    const { data, recordTimer } = this.values({ model, id });
    this.debug("cache.get:data+recordTimer", ...arguments);
    if (recordTimer) {
      return data;
    }
  },
  setRecord(record, details) {
    this.debug("cache.setRecord", ...arguments);
    let { recordTimer, presets } = this.values(details);
    if (recordTimer) {
      clearTimeout(recordTimer);
    }
    recordTimer = setTimeout(() => {
      this.values(details, { record: void 0, recordTimer: void 0 });
    }, RECORD_TIMEOUT);
    this.values(details, {
      record: record !== void 0 ? record : null,
      recordTimer
    });
    if (presets) {
      for (let preset of presets) {
        this.set(preset);
      }
      this.values(details, { presets: void 0 });
    }
    const result = this.get(details.model, details.id);
    return result !== void 0 ? result : record;
  },
  async getFetch(model, id, fetch) {
    if (this.options.enabled) {
      this.debug("cache.getFetch", ...arguments);
      const value = this.get(model, id);
      if (value !== void 0) {
        return value;
      }
    }
    const record = await fetch();
    return this.setRecord(record, { model, id });
  },
  clear(model = void 0, id = void 0) {
    this.debug("cache.clear", ...arguments);
    if (model) {
      if (id) {
        set__default["default"](VALUES, `${model}.${id}`, void 0);
      } else {
        set__default["default"](VALUES, model, void 0);
      }
    } else {
      VALUES = {};
    }
  }
};

function methods$a(request) {
  const { get, list } = defaultMethods(request, "/attributes", ["list", "get"]);
  return {
    get: (id, ...args) => {
      return cacheApi.getFetch("attributes", id, () => get(id, ...args));
    },
    list
  };
}

var __defProp$7 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));
let OPTIONS;
function methods$9(request, opt) {
  OPTIONS = opt;
  const { get: get2, list } = defaultMethods(request, "/products", ["list", "get"]);
  return {
    get: (id, ...args) => {
      return cacheApi.getFetch("products", id, () => get2(id, ...args));
    },
    list,
    variation: calculateVariation,
    categories: getCategories,
    attributes: getAttributes,
    priceRange: getPriceRange,
    filters: getFilters,
    filterableAttributeFilters: (products, options) => getFilterableAttributeFilters(request, products, options)
  };
}
function getProductOptionIndex(product, filter = void 0) {
  if (!product.options) {
    return {};
  }
  const productOptions = filter ? product.options.filter(filter) : product.options;
  return reduce(
    productOptions,
    (acc, op) => {
      const values = reduce(
        op.values,
        (acc2, val) => __spreadProps$4(__spreadValues$7({}, acc2), {
          [val.id]: __spreadProps$4(__spreadValues$7({}, val), { id: val.id }),
          [val.name]: __spreadProps$4(__spreadValues$7({}, val), { id: val.id })
        }),
        {}
      );
      return __spreadProps$4(__spreadValues$7({}, acc), {
        [op.id]: __spreadProps$4(__spreadValues$7({}, op), { values }),
        [op.name]: __spreadProps$4(__spreadValues$7({}, op), { values })
      });
    },
    {}
  );
}
function cleanProductOptions(options) {
  let result = options || [];
  if (options && typeof options === "object" && !(options instanceof Array)) {
    result = [];
    for (const key in options) {
      result.push({
        id: key,
        value: options[key]
      });
    }
  }
  if (result instanceof Array) {
    return result.map((op) => ({
      id: op.id || op.name,
      value: op.value
    }));
  }
  return result;
}
function findVariantWithOptionValueIds(product, ids) {
  if (ids.length > 0) {
    const variants = product.variants && product.variants.results;
    if (variants.length > 0) {
      for (const variant of variants) {
        const variantObj = toSnake(variant);
        const matched = isEqual__default["default"](variantObj.option_value_ids.sort(), ids.sort());
        if (matched) {
          return variant;
        }
      }
    }
  }
  return null;
}
function calculateVariation(input, options, purchaseOption) {
  const product = OPTIONS.useCamelCase ? toSnake(input) : input;
  const purchaseOp = findPurchaseOption(product, purchaseOption);
  const variation = __spreadProps$4(__spreadValues$7({}, product), {
    price: purchaseOp.price || 0,
    sale_price: purchaseOp.sale_price,
    orig_price: purchaseOp.orig_price,
    stock_status: product.stock_status
  });
  let optionPrice = 0;
  const variantOptionValueIds = [];
  const cleanOptions = cleanProductOptions(options);
  const index = getProductOptionIndex(product);
  for (const option of cleanOptions) {
    if (index[option.id] && index[option.id].values[option.value]) {
      if (index[option.id].variant) {
        variantOptionValueIds.push(index[option.id].values[option.value].id);
      } else {
        optionPrice += index[option.id].values[option.value].price || 0;
      }
    }
  }
  if (variantOptionValueIds.length > 0) {
    const variant = findVariantWithOptionValueIds(
      product,
      variantOptionValueIds
    );
    if (variant) {
      let variantPurchaseOp = purchaseOp;
      try {
        variantPurchaseOp = findPurchaseOption(variant, purchaseOption);
      } catch (err) {
      }
      variation.variant_id = variant.id;
      variation.price = variantPurchaseOp.price || 0;
      variation.sale_price = variantPurchaseOp.sale_price || purchaseOp.sale_price;
      variation.orig_price = variantPurchaseOp.orig_price || purchaseOp.orig_price;
      variation.stock_status = variant.stock_status;
      variation.stock_level = variant.stock_level || 0;
      variation.images = (variant.images && variant.images.length ? variant.images : product.images) || [];
    }
  }
  if (optionPrice > 0) {
    variation.price += optionPrice;
    if (variation.sale_price) {
      variation.sale_price += optionPrice;
    }
    if (variation.orig_price) {
      variation.orig_price += optionPrice;
    }
  }
  if (variation.sale_price === void 0) {
    delete variation.sale_price;
  }
  if (variation.orig_price === void 0) {
    delete variation.orig_price;
  }
  return OPTIONS.useCamelCase ? toCamel(variation) : variation;
}
function findPurchaseOption(product, purchaseOption) {
  const plan = get__default["default"](purchaseOption, "plan_id", get__default["default"](purchaseOption, "plan"));
  const type = get__default["default"](
    purchaseOption,
    "type",
    typeof purchaseOption === "string" ? purchaseOption : plan !== void 0 ? "subscription" : "standard"
  );
  let option = get__default["default"](product, `purchase_options.${type}`);
  if (!option && type !== "standard") {
    throw new Error(
      `Product purchase option '${type}' not found or not active`
    );
  }
  if (option) {
    if (option.plans) {
      if (plan !== void 0) {
        option = find__default["default"](option.plans, { id: plan });
        if (!option) {
          throw new Error(
            `Subscription purchase plan '${plan}' not found or not active`
          );
        }
      } else {
        option = option.plans[0];
      }
    }
    return __spreadProps$4(__spreadValues$7({}, option), {
      price: typeof option.price === "number" ? option.price : product.price,
      sale_price: typeof option.sale_price === "number" ? option.sale_price : product.sale_price,
      orig_price: typeof option.orig_price === "number" ? option.orig_price : product.orig_price
    });
  }
  return {
    type: "standard",
    price: product.price,
    sale_price: product.sale_price,
    orig_price: product.orig_price
  };
}
async function getFilterableAttributeFilters(request, products, options) {
  const { results: filterableAttributes } = await methods$a(
    request).list({
    filterable: true
  });
  return getFilters(products, __spreadProps$4(__spreadValues$7({}, options), { filterableAttributes }));
}
function getFilters(products, options = {}) {
  let attributes = (options.attributes || options.attributes === void 0) && getAttributes(products);
  if (options.filterableAttributes) {
    attributes = attributes.filter(
      (productAttr) => options.filterableAttributes.find(
        (filterableAttr) => productAttr.id === filterableAttr.id
      )
    );
  }
  const categories = (options.categories || options.categories === void 0) && getCategories(products);
  const priceRange = (options.price || options.price === void 0) && getPriceRange(products);
  let filters = [];
  if (priceRange) {
    filters.push({
      id: "price",
      label: "Price",
      type: "range",
      options: [
        {
          value: priceRange.min,
          label: priceRange.min
        },
        {
          value: priceRange.max,
          label: priceRange.max
        }
      ],
      interval: priceRange.interval
    });
  }
  if (categories && categories.length > 0) {
    filters.push({
      id: "category",
      label: "Category",
      type: "select",
      options: categories.map((category) => ({
        value: category.slug,
        label: category.name
      }))
    });
  }
  if (attributes && attributes.length > 0) {
    filters = [
      ...filters,
      ...reduce(
        attributes,
        (acc, attr) => [
          ...acc,
          ...attr.id !== "category" && attr.id !== "price" && attr.values instanceof Array && attr.values.length > 0 ? [
            {
              id: attr.id,
              label: attr.name,
              type: "select",
              options: attr.values.map((value) => ({
                value,
                label: value
              }))
            }
          ] : []
        ],
        []
      )
    ];
  }
  return filters;
}
function getCategories(products) {
  const categories = [];
  const collection = products && products.results || (products.id ? [products] : products);
  if (collection instanceof Array) {
    for (let product of collection) {
      if (product.categories) {
        for (let category of product.categories) {
          if (!category)
            continue;
          let ex = find__default["default"](categories, { id: category.id });
          if (!ex) {
            categories.push(category);
          }
        }
      }
    }
  }
  return categories;
}
function getAttributes(products) {
  const attributes = [];
  const collection = products && products.results || (products.id ? [products] : products);
  if (collection instanceof Array) {
    for (let product of collection) {
      if (product.attributes) {
        for (let id in product.attributes) {
          if (!product.attributes[id])
            continue;
          const value = product.attributes[id].value;
          let attr = find__default["default"](attributes, { id: snakeCase__default["default"](id) });
          if (attr) {
            attr.values = uniq__default["default"]([
              ...attr.values,
              ...value instanceof Array ? value : [value]
            ]);
          } else {
            attributes.push(__spreadProps$4(__spreadValues$7({}, product.attributes[id]), {
              value: void 0,
              values: [...value instanceof Array ? value : [value]]
            }));
          }
        }
      }
    }
  }
  return attributes;
}
function getPriceRange(products) {
  let min;
  let max;
  let interval;
  const collection = products && products.results || (products.id ? [products] : products);
  if (collection instanceof Array) {
    for (let product of collection) {
      if (max === void 0 || product.price > max) {
        max = Math.ceil(product.price);
      }
      if (min === void 0 || product.price < min) {
        min = Math.floor(product.price);
      }
    }
  }
  if (min === max) {
    return null;
  }
  interval = Math.ceil((max - min) / 10) || 1;
  if (interval > 1e3) {
    interval = 1e3;
  } else if (interval > 100) {
    interval = 100;
  } else if (interval > 10) {
    interval = 10;
  }
  if (max % interval > 0) {
    max = interval + max - max % interval;
  }
  if (min % interval > 0) {
    min = min - min % interval;
  }
  while ((max - min) / interval % 1 > 0) {
    max++;
  }
  return {
    min,
    max,
    interval
  };
}

var __defProp$6 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
function methods$8(request, options) {
  return {
    state: null,
    order: null,
    settings: null,
    requested: false,
    pendingRequests: [],
    cacheClear: null,
    async requestStateChange(method, url, id, data) {
      return this.requestStateSync(async () => {
        const result = await request(method, url, id, data);
        if (result && result.errors) {
          return result;
        }
        this.state = result;
        return result;
      });
    },
    async requestStateSync(handler) {
      if (this.state) {
        return await handler();
      } else if (this.requested) {
        return new Promise((resolve) => {
          this.pendingRequests.push({ handler, resolve });
        });
      }
      this.requested = true;
      const result = await handler();
      this.requested = false;
      while (this.pendingRequests.length > 0) {
        const { handler: handler2, resolve } = this.pendingRequests.shift();
        resolve(handler2());
      }
      return result;
    },
    get() {
      let data;
      if (this.cacheClear) {
        this.cacheClear = null;
        data = { $cache: false };
      }
      return this.requestStateChange("get", "/cart", void 0, data);
    },
    clearCache() {
      this.cacheClear = true;
    },
    getItemData(item, data = {}) {
      let result = cloneDeep__default["default"](item);
      if (typeof item === "string") {
        result = __spreadProps$3(__spreadValues$6({}, data || {}), {
          product_id: item
        });
      }
      if (result && result.options) {
        result.options = cleanProductOptions(result.options);
      }
      return result;
    },
    addItem(item, data) {
      return this.requestStateChange(
        "post",
        "/cart/items",
        this.getItemData(item, data)
      );
    },
    updateItem(id, item) {
      return this.requestStateChange(
        "put",
        `/cart/items/${id}`,
        this.getItemData(item)
      );
    },
    setItems(input) {
      let items = input;
      if (items && items.map) {
        items = items.map(this.getItemData);
      }
      return this.requestStateChange("put", "/cart/items", items);
    },
    removeItem(id) {
      return this.requestStateChange("delete", `/cart/items/${id}`);
    },
    recover(checkoutId) {
      return this.requestStateChange("put", `/cart/recover/${checkoutId}`);
    },
    update(input) {
      let data = input;
      if (data.items && data.items.map) {
        data = __spreadProps$3(__spreadValues$6({}, data), {
          items: data.items.map(this.getItemData)
        });
      }
      return this.requestStateChange("put", `/cart`, data);
    },
    applyCoupon(code) {
      return this.requestStateChange("put", "/cart/coupon", { code });
    },
    removeCoupon() {
      return this.requestStateChange("delete", "/cart/coupon");
    },
    applyGiftcard(code) {
      return this.requestStateChange("post", "/cart/giftcards", { code });
    },
    removeGiftcard(id) {
      return this.requestStateChange("delete", `/cart/giftcards/${id}`);
    },
    async getShippingRates() {
      await this.requestStateChange("get", "/cart/shipment-rating");
      return this.state[options.useCamelCase ? "shipmentRating" : "shipment_rating"];
    },
    async submitOrder() {
      const result = await request("post", "/cart/order");
      if (result.errors) {
        return result;
      }
      this.state = null;
      this.order = result;
      return result;
    },
    async getOrder(checkoutId = void 0) {
      let result;
      if (checkoutId) {
        result = await request("get", `/cart/order`, {
          checkout_id: checkoutId
        });
      } else {
        result = await request("get", `/cart/order`);
      }
      this.order = result;
      return result;
    },
    async getSettings() {
      this.settings = await request("get", "/cart/settings");
      return this.settings;
    }
  };
}

function methods$7(request) {
  return {
    state: null,
    async requestStateChange(method, url, id, data) {
      const result = await request(method, url, id, data);
      if (result && result.errors) {
        return result;
      }
      return this.state = result;
    },
    get(query) {
      return this.requestStateChange("get", "/account", query);
    },
    create(data) {
      return this.requestStateChange("post", "/account", data);
    },
    update(data) {
      return this.requestStateChange("put", "/account", data);
    },
    login(email, password) {
      if (password && password.password_token) {
        return this.requestStateChange("post", "/account/login", {
          email,
          password_token: password.password_token
        });
      }
      return this.requestStateChange("post", "/account/login", {
        email,
        password
      });
    },
    logout() {
      this.state = null;
      return request("post", "/account/logout");
    },
    recover(data) {
      return request("post", "/account/recover", data);
    },
    listAddresses(query) {
      return request("get", "/account/addresses", query);
    },
    createAddress(data) {
      return request("post", "/account/addresses", data);
    },
    updateAddress(id, data) {
      return request("put", `/account/addresses/${id}`, data);
    },
    deleteAddress(id) {
      return request("delete", `/account/addresses/${id}`);
    },
    listCards(query) {
      return request("get", "/account/cards", query);
    },
    createCard(data) {
      return request("post", "/account/cards", data);
    },
    updateCard(id, data) {
      return request("put", `/account/cards/${id}`, data);
    },
    deleteCard(id) {
      return request("delete", `/account/cards/${id}`);
    },
    listOrders(query) {
      return request("get", `/account/orders`, query);
    },
    getOrder(id) {
      return request("get", `/account/orders/${id}`);
    },
    getAddresses(query) {
      return request("get", "/account/addresses", query);
    },
    getCards(query) {
      return request("get", "/account/cards", query);
    },
    getOrders(query) {
      return request("get", `/account/orders`, query);
    }
  };
}

function methods$6(request) {
  const { get, list } = defaultMethods(request, "/categories", ["list", "get"]);
  return {
    get: (id, ...args) => {
      return cacheApi.getFetch("categories", id, () => get(id, ...args));
    },
    list
  };
}

function methods$5(request) {
  const { get, list } = defaultMethods(request, "/subscriptions", [
    "list",
    "get"
  ]);
  return {
    get: (id, ...args) => {
      return cacheApi.getFetch("subscriptions", id, () => get(id, ...args));
    },
    list,
    getCleanData(data) {
      if (data && data.options) {
        data.options = cleanProductOptions(data.options);
      }
      if (data.items && data.items.map) {
        data.items = data.items.map((item) => {
          if (item.options) {
            item.options = cleanProductOptions(item.options);
          }
          return item;
        });
      }
      return data;
    },
    create(data) {
      return request("post", "/subscriptions", this.getCleanData(data));
    },
    update(id, data) {
      return request("put", `/subscriptions/${id}`, this.getCleanData(data));
    },
    addItem(id, item) {
      return request(
        "post",
        `/subscriptions/${id}/items`,
        this.getCleanData(item)
      );
    },
    setItems(id, items) {
      if (items && items.map) {
        items = items.map(this.getCleanData);
      }
      return request("put", `/subscriptions/${id}/items`, items);
    },
    updateItem(id, itemId, item) {
      return request(
        "put",
        `/subscriptions/${id}/items/${itemId}`,
        this.getCleanData(item)
      );
    },
    removeItem(id, itemId) {
      return request("delete", `/subscriptions/${id}/items/${itemId}`);
    }
  };
}

var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
function methods$4(request, opt) {
  return {
    get: (type, id, query) => {
      return cacheApi.getFetch(
        `content_${type}`,
        id,
        () => request("get", `/content/${type}`, id, __spreadValues$5({
          $preview: opt.previewContent
        }, query || {}))
      );
    },
    list: (type, query) => request("get", `/content/${type}`, void 0, query)
  };
}

var __defProp$4 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
function methods$3(request, opt) {
  return {
    state: null,
    menuState: null,
    paymentState: null,
    subscriptionState: null,
    sessionState: null,
    localizedState: {},
    refresh() {
      this.state = null;
      this.menuState = null;
      this.paymentState = null;
      this.subscriptionState = null;
      this.sessionState = null;
      this.localizedState = {};
      return this.get();
    },
    getState(uri, stateName, { id = void 0, def = void 0, refresh = false } = {}) {
      if (!this[stateName] || refresh) {
        this[stateName] = request("get", uri);
      }
      if (this[stateName] && typeof this[stateName].then === "function") {
        return this[stateName].then((state) => {
          this[stateName] = state;
          return this.getLocalizedState(stateName, id, def);
        });
      }
      return this.getLocalizedState(stateName, id, def);
    },
    getLocalizedState(stateName, id, def) {
      const locale = this.getCurrentLocale();
      const ls = this.localizedState;
      if (ls.code !== locale) {
        ls.code = locale;
        delete ls[locale];
      }
      if (!ls[locale]) {
        ls[locale] = {};
      }
      if (!ls[locale][stateName]) {
        ls[locale][stateName] = this.decodeLocale(this[stateName]);
      }
      return id ? get__default["default"](ls[locale][stateName], id, def) : ls[locale][stateName];
    },
    findState(uri, stateName, { where = void 0, def = void 0 } = {}) {
      const state = this.getState(uri, stateName);
      if (state && typeof state.then === "function") {
        return state.then((state2) => find__default["default"](state2, where) || def);
      }
      return find__default["default"](state, where) || def;
    },
    get(id = void 0, def = void 0) {
      return this.getState("/settings", "state", { id, def });
    },
    getCurrentLocale() {
      return opt.api.locale.selected();
    },
    getStoreLocale() {
      return get__default["default"](this.state, "store.locale");
    },
    getStoreLocales() {
      return get__default["default"](this.state, "store.locales");
    },
    set({ model, path, value }) {
      const locale = this.getCurrentLocale();
      const stateName = model ? `${model.replace(/s$/, "")}State` : "state";
      const { useCamelCase } = opt;
      let mergeData = {};
      if (path)
        set__default["default"](mergeData, path, value);
      else
        mergeData = value;
      if (useCamelCase) {
        mergeData = toCamel(mergeData);
      }
      this[stateName] = merge(this[stateName] || {}, mergeData);
      if (this.localizedState[locale]) {
        this.localizedState[locale][stateName] = this.decodeLocale(
          this[stateName]
        );
      }
    },
    menus(id = void 0, def = void 0) {
      return this.findState("/settings/menus", "menuState", {
        where: { id },
        def
      });
    },
    payments(id = void 0, def = void 0) {
      return this.getState("/settings/payments", "paymentState", { id, def });
    },
    subscriptions(id = void 0, def = void 0) {
      return this.getState("/settings/subscriptions", "subscriptionState", {
        id,
        def
      });
    },
    session(id = void 0, def = void 0) {
      return this.getState("/session", "sessionState", { id, def });
    },
    decodeLocale(values) {
      const locale = this.getCurrentLocale();
      if (!values || typeof values !== "object") {
        return values;
      }
      let configs = this.getStoreLocales();
      if (configs) {
        configs = configs.reduce(
          (acc, config) => __spreadProps$2(__spreadValues$4({}, acc), {
            [config.code]: config
          }),
          {}
        );
      } else {
        configs = {};
      }
      return decodeLocaleObjects(cloneDeep__default["default"](values), locale, configs, opt);
    },
    async load() {
      try {
        const { settings, menus, payments, subscriptions, session } = await request("get", "/settings/all");
        this.localizedState = {};
        this.set({
          value: settings
        });
        this.set({
          model: "menus",
          value: menus
        });
        this.set({
          model: "payments",
          value: payments
        });
        this.set({
          model: "subscriptions",
          value: subscriptions
        });
        this.set({
          model: "session",
          value: session
        });
      } catch (err) {
        console.error(`Swell: unable to loading settings (${err})`);
      }
    }
  };
}
function decodeLocaleObjects(values, locale, configs, opt) {
  if (isObject(values)) {
    const keys = Object.keys(values);
    for (let key of keys) {
      if (key === "$locale") {
        decodeLocaleValue(locale, values, key, configs, opt);
        delete values.$locale;
      }
      if (values[key] !== void 0) {
        values[key] = decodeLocaleObjects(values[key], locale, configs, opt);
      }
    }
  } else if (values instanceof Array) {
    for (var i = 0; i < values.length; i++) {
      values[i] = decodeLocaleObjects(values[i], locale, configs, opt);
    }
  }
  return values;
}
function decodeLocaleValue(locale, values, key, configs, opt) {
  if (!locale || !isObject(values[key])) {
    return;
  }
  let returnLocaleKey;
  let returnLocaleConfig;
  const localeKeys = Object.keys(values[key]);
  for (let localeKey of localeKeys) {
    const shortKey = localeKey.replace(/\-.+$/, "");
    const transformedLocale = opt.useCamelCase ? camelCase__default["default"](locale) : locale;
    if (localeKey === locale || localeKey === transformedLocale || shortKey === transformedLocale) {
      returnLocaleKey = locale;
      returnLocaleConfig = configs[locale];
    }
  }
  if (!returnLocaleKey && isObject(configs)) {
    const localeKeys2 = Object.keys(configs);
    for (let localeKey of localeKeys2) {
      const shortKey = localeKey.replace(/\-.+$/, "");
      if (localeKey === locale || shortKey === locale) {
        returnLocaleKey = localeKey;
        returnLocaleConfig = configs[localeKey];
      }
    }
  }
  let fallbackKeys;
  let fallbackValues = {};
  if (returnLocaleConfig) {
    let fallbackKey = returnLocaleConfig.fallback;
    const origFallbackKey = fallbackKey;
    while (fallbackKey) {
      fallbackKeys = fallbackKeys || [];
      fallbackKeys.push(fallbackKey);
      fallbackValues = __spreadValues$4(__spreadValues$4({}, values[key][fallbackKey] || {}), fallbackValues);
      fallbackKey = configs[fallbackKey] && configs[fallbackKey].fallback;
      if (origFallbackKey === fallbackKey) {
        break;
      }
    }
  }
  let localeValues = __spreadValues$4(__spreadValues$4({}, fallbackValues), values[key][returnLocaleKey] || {});
  const valueKeys = Object.keys(localeValues);
  for (let valueKey of valueKeys) {
    const hasValue = localeValues[valueKey] !== null && localeValues[valueKey] !== "";
    let shouldFallback = fallbackKeys && !hasValue;
    if (shouldFallback) {
      for (let fallbackKey of fallbackKeys) {
        shouldFallback = !values[key][fallbackKey] || values[key][fallbackKey][valueKey] === null || values[key][fallbackKey][valueKey] === "";
        if (shouldFallback) {
          if (fallbackKey === "none") {
            values[valueKey] = null;
            break;
          }
          continue;
        } else {
          values[valueKey] = values[key][fallbackKey][valueKey];
          break;
        }
      }
    } else {
      if (hasValue) {
        values[valueKey] = localeValues[valueKey];
      }
    }
  }
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const addressFieldsMap$1 = {
  city: "city",
  country: "country",
  line1: "address1",
  line2: "address2",
  postal_code: "zip",
  state: "state"
};
const billingFieldsMap = {
  name: "name",
  phone: "phone"
};
function mapValues(fieldsMap, data) {
  const result = {};
  for (const [destinationKey, sourceKey] of Object.entries(fieldsMap)) {
    const value = data[sourceKey];
    if (value) {
      result[destinationKey] = value;
    }
  }
  return result;
}
function getBillingDetails(cart) {
  const details = __spreadValues$3({}, mapValues(billingFieldsMap, cart.billing));
  if (cart.account && cart.account.email) {
    details.email = cart.account.email;
  }
  const address = mapValues(addressFieldsMap$1, cart.billing);
  if (!isEmpty__default["default"](address)) {
    details.address = address;
  }
  return details;
}
function getKlarnaItems(cart) {
  const currency = toLower__default["default"](get__default["default"](cart, "currency", "eur"));
  const items = map__default["default"](cart.items, (item) => ({
    type: "sku",
    description: item.product.name,
    quantity: item.quantity,
    currency,
    amount: Math.round(toNumber__default["default"](item.price_total - item.discount_total) * 100)
  }));
  const tax = get__default["default"](cart, "tax_included_total");
  if (tax) {
    items.push({
      type: "tax",
      description: "Taxes",
      currency,
      amount: Math.round(toNumber__default["default"](tax) * 100)
    });
  }
  const shipping = get__default["default"](cart, "shipping", {});
  const shippingTotal = get__default["default"](cart, "shipment_total", {});
  if (shipping.price) {
    items.push({
      type: "shipping",
      description: shipping.service_name,
      currency,
      amount: Math.round(toNumber__default["default"](shippingTotal) * 100)
    });
  }
  return items;
}
function setKlarnaBillingShipping(source, data) {
  const shippingNameFieldsMap = {
    shipping_first_name: "first_name",
    shipping_last_name: "last_name"
  };
  const shippingFieldsMap = {
    phone: "phone"
  };
  const billingNameFieldsMap = {
    first_name: "first_name",
    last_name: "last_name"
  };
  const billingFieldsMap2 = {
    email: "email"
  };
  const fillValues = (fieldsMap, data2) => reduce__default["default"](
    fieldsMap,
    (acc, srcKey, destKey) => {
      const value = data2[srcKey];
      if (value) {
        acc[destKey] = value;
      }
      return acc;
    },
    {}
  );
  source.klarna = __spreadValues$3(__spreadValues$3({}, source.klarna), fillValues(shippingNameFieldsMap, data.shipping));
  const shipping = fillValues(shippingFieldsMap, data.shipping);
  const shippingAddress = fillValues(addressFieldsMap$1, data.shipping);
  if (shipping || shippingAddress) {
    source.source_order.shipping = __spreadValues$3(__spreadValues$3({}, shipping ? shipping : {}), shippingAddress ? { address: shippingAddress } : {});
  }
  source.klarna = __spreadValues$3(__spreadValues$3({}, source.klarna), fillValues(
    billingNameFieldsMap,
    data.billing || get__default["default"](data, "account.billing") || data.shipping
  ));
  const billing = fillValues(billingFieldsMap2, data.account);
  const billingAddress = fillValues(
    addressFieldsMap$1,
    data.billing || get__default["default"](data, "account.billing") || data.shipping
  );
  if (billing || billingAddress) {
    source.owner = __spreadValues$3(__spreadValues$3({}, billing ? billing : {}), billingAddress ? { address: billingAddress } : {});
  }
}
function setBancontactOwner(source, data) {
  const fillValues = (fieldsMap, data2) => reduce__default["default"](
    fieldsMap,
    (acc, srcKey, destKey) => {
      const value = data2[srcKey];
      if (value) {
        acc[destKey] = value;
      }
      return acc;
    },
    {}
  );
  const { account = {}, billing, shipping } = data;
  const billingData = __spreadValues$3(__spreadValues$3(__spreadValues$3(__spreadValues$3({}, account.shipping), account.billing), shipping), billing);
  const billingAddress = fillValues(addressFieldsMap$1, billingData);
  source.owner = __spreadValues$3(__spreadValues$3({
    email: account.email,
    name: billingData.name || account.name
  }, billingData.phone ? { phone: billingData.phone } : account.phone ? { phone: account.phone } : {}), !isEmpty__default["default"](billingAddress) ? { address: billingAddress } : {});
}
async function createPaymentMethod(stripe, cardElement, authorize, cart) {
  const billingDetails = getBillingDetails(cart);
  const { paymentMethod, error: paymentMethodError } = await stripe.createPaymentMethod(__spreadValues$3({
    type: "card",
    card: cardElement
  }, !isEmpty__default["default"](billingDetails) ? { billing_details: billingDetails } : {}));
  if (paymentMethodError) {
    return { error: paymentMethodError };
  }
  const customer = cart.account && cart.account.stripe_customer;
  const authorization = await authorize({
    gateway: "stripe",
    params: __spreadValues$3({
      usage: "off_session",
      payment_method: paymentMethod.id
    }, customer ? { customer } : {})
  });
  if (!authorization) {
    return;
  }
  const { error: setupIntentError } = await stripe.confirmCardSetup(
    authorization.client_secret
  );
  return setupIntentError ? { error: setupIntentError } : authorization.card;
}
async function createIDealPaymentMethod(stripe, element, cart) {
  const billingDetails = getBillingDetails(cart);
  return await stripe.createPaymentMethod(__spreadValues$3({
    type: "ideal",
    ideal: element
  }, billingDetails ? { billing_details: billingDetails } : {}));
}
async function createKlarnaSource(stripe, cart) {
  const sourceObject = {
    type: "klarna",
    flow: "redirect",
    amount: Math.round(get__default["default"](cart, "grand_total", 0) * 100),
    currency: toLower__default["default"](get__default["default"](cart, "currency", "eur")),
    klarna: {
      product: "payment",
      purchase_country: get__default["default"](cart, "settings.country", "DE")
    },
    source_order: {
      items: getKlarnaItems(cart)
    },
    redirect: {
      return_url: window.location.href
    }
  };
  setKlarnaBillingShipping(sourceObject, cart);
  return await stripe.createSource(sourceObject);
}
async function createBancontactSource(stripe, cart) {
  const sourceObject = {
    type: "bancontact",
    amount: Math.round(get__default["default"](cart, "grand_total", 0) * 100),
    currency: toLower__default["default"](get__default["default"](cart, "currency", "eur")),
    redirect: {
      return_url: window.location.href
    }
  };
  setBancontactOwner(sourceObject, cart);
  return await stripe.createSource(sourceObject);
}
function stripeAmountByCurrency(currency, amount) {
  const zeroDecimalCurrencies = [
    "BIF",
    "DJF",
    "JPY",
    "KRW",
    "PYG",
    "VND",
    "XAF",
    "XPF",
    "CLP",
    "GNF",
    "KMF",
    "MGA",
    "RWF",
    "VUV",
    "XOF"
  ];
  if (zeroDecimalCurrencies.includes(currency.toUpperCase())) {
    return amount;
  } else {
    return Math.round(amount * 100);
  }
}

function generateOrderId() {
  return Math.random().toString(36).substr(2, 9);
}
async function createQuickpayCard(authorize) {
  const returnUrl = window.location.origin + window.location.pathname;
  const authorization = await authorize({
    gateway: "quickpay",
    params: {
      action: "create",
      continueurl: `${returnUrl}?gateway=quickpay&redirect_status=succeeded`,
      cancelurl: `${returnUrl}?gateway=quickpay&redirect_status=canceled`
    }
  });
  if (authorization && authorization.url) {
    window.location.replace(authorization.url);
  }
}
async function getQuickpayCardDetais(id, authorize) {
  return await authorize({
    gateway: "quickpay",
    params: { action: "get", id }
  });
}
async function createQuickpayPayment(cart, createIntent) {
  return await createIntent({
    gateway: "quickpay",
    intent: {
      currency: get__default["default"](cart, "currency", "USD"),
      order_id: generateOrderId()
    }
  });
}

async function createPaysafecardPayment(cart, createIntent) {
  const returnUrl = window.location.origin + window.location.pathname;
  const url = `${returnUrl}?gateway=paysafecard`;
  return await createIntent({
    gateway: "paysafecard",
    intent: {
      type: "PAYSAFECARD",
      amount: cart.grand_total,
      redirect: {
        success_url: url,
        failure_url: url
      },
      notification_url: url,
      customer: {
        id: get__default["default"](cart, "account.id")
      },
      currency: get__default["default"](cart, "currency", "USD")
    }
  });
}

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const addressFieldsMap = {
  given_name: "first_name",
  family_name: "last_name",
  city: "city",
  country: "country",
  phone: "phone",
  postal_code: "zip",
  street_address: "address1",
  street_address2: "address2",
  region: "state"
};
const mapFields = (fieldsMap, data) => reduce__default["default"](
  fieldsMap,
  (acc, srcKey, destKey) => {
    const value = data[srcKey];
    if (value) {
      acc[destKey] = value;
    }
    return acc;
  },
  {}
);
const mapAddressFields = (cart, addressField) => __spreadProps$1(__spreadValues$2({}, mapFields(addressFieldsMap, cart[addressField])), {
  email: get__default["default"](cart, "account.email")
});
function getOrderLines(cart) {
  const items = map__default["default"](cart.items, (item) => ({
    type: "physical",
    name: get__default["default"](item, "product.name"),
    reference: get__default["default"](item, "product.sku") || get__default["default"](item, "product.slug"),
    quantity: item.quantity,
    unit_price: Math.round(toNumber__default["default"](item.price - item.discount_each) * 100),
    total_amount: Math.round(
      toNumber__default["default"](item.price_total - item.discount_total) * 100
    ),
    tax_rate: 0,
    total_tax_amount: 0
  }));
  const tax = get__default["default"](cart, "tax_included_total");
  const taxAmount = toNumber__default["default"](tax) * 100;
  if (tax) {
    items.push({
      type: "sales_tax",
      name: "Taxes",
      quantity: 1,
      unit_price: taxAmount,
      total_amount: taxAmount,
      tax_rate: 0,
      total_tax_amount: 0
    });
  }
  const shipping = get__default["default"](cart, "shipping", {});
  const shippingTotal = get__default["default"](cart, "shipment_total", {});
  const shippingAmount = toNumber__default["default"](shippingTotal) * 100;
  if (shipping.price) {
    items.push({
      type: "shipping_fee",
      name: shipping.service_name,
      quantity: 1,
      unit_price: shippingAmount,
      total_amount: shippingAmount,
      tax_rate: 0,
      total_tax_amount: 0
    });
  }
  return items;
}
async function createKlarnaSession(cart, createIntent) {
  const returnUrl = `${window.location.origin}${window.location.pathname}?gateway=klarna_direct&sid={{session_id}}`;
  const successUrl = `${returnUrl}&authorization_token={{authorization_token}}`;
  return createIntent({
    gateway: "klarna",
    intent: {
      locale: cart.display_locale || get__default["default"](cart, "settings.locale") || "en-US",
      purchase_country: get__default["default"](cart, "billing.country") || get__default["default"](cart, "shipping.country"),
      purchase_currency: cart.currency,
      billing_address: mapAddressFields(cart, "billing"),
      shipping_address: mapAddressFields(cart, "shipping"),
      order_amount: Math.round(get__default["default"](cart, "grand_total", 0) * 100),
      order_lines: JSON.stringify(getOrderLines(cart)),
      merchant_urls: {
        success: successUrl,
        back: returnUrl,
        cancel: returnUrl,
        error: returnUrl,
        failure: returnUrl
      }
    }
  });
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const LOADING_SCRIPTS = {};
const CARD_ELEMENTS = {};
const API = {};
let options$1 = null;
function methods$2(request, opts) {
  options$1 = opts || options$1;
  return {
    params: null,
    methodSettings: null,
    get(id) {
      return request("get", "/payments", id);
    },
    async methods() {
      if (this.methodSettings) {
        return this.methodSettings;
      }
      const result = await request("get", "/payment/methods");
      return this.methodSettings = result;
    },
    async createElements(elementParams) {
      this.params = elementParams || {};
      const cart = toSnake(await methods$8(request, options$1).get());
      if (!cart) {
        throw new Error("Cart not found");
      }
      const payMethods = toSnake(
        await methods$3(request, options$1).payments()
      );
      if (payMethods.error) {
        throw new Error(payMethods.error);
      }
      await render(request, cart, payMethods, this.params);
    },
    async tokenize(params) {
      const cart = toSnake(await methods$8(request, options$1).get());
      if (!cart) {
        throw new Error("Cart not found");
      }
      const payMethods = toSnake(
        await methods$3(request, options$1).payments()
      );
      if (payMethods.error) {
        throw new Error(payMethods.error);
      }
      return await paymentTokenize(
        request,
        params || this.params,
        payMethods,
        cart
      );
    },
    async handleRedirect(params) {
      const cart = toSnake(await methods$8(request, options$1).get());
      if (!cart) {
        throw new Error("Cart not found");
      }
      return await handleRedirect(request, params || this.params, cart);
    },
    async authenticate(id) {
      const payment = await this.get(id);
      if (!payment) {
        throw new Error("Payment not found");
      }
      const payMethods = toSnake(
        await methods$3(request, options$1).payments()
      );
      if (payMethods.error) {
        throw new Error(payMethods.error);
      }
      return await authenticate(request, payment, payMethods);
    },
    async createIntent(data) {
      const intent = await vaultRequest("post", "/intent", data);
      if (intent.errors) {
        const param = Object.keys(intent.errors)[0];
        const err = new Error(intent.errors[param].message || "Unknown error");
        err.code = "vault_error";
        err.status = 402;
        err.param = param;
        throw err;
      }
      return intent;
    },
    async updateIntent(data) {
      const intent = await vaultRequest("put", "/intent", data);
      if (intent.errors) {
        const param = Object.keys(intent.errors)[0];
        const err = new Error(intent.errors[param].message || "Unknown error");
        err.code = "vault_error";
        err.status = 402;
        err.param = param;
        throw err;
      }
      return intent;
    },
    async authorizeGateway(data) {
      const authorization = await vaultRequest("post", "/authorization", data);
      if (authorization.errors) {
        const param = Object.keys(authorization.errors)[0];
        const err = new Error(
          authorization.errors[param].message || "Unknown error"
        );
        err.code = "vault_error";
        err.status = 402;
        err.param = param;
        throw err;
      }
      return authorization;
    }
  };
}
async function render(request, cart, payMethods, params) {
  if (params.card) {
    if (!payMethods.card) {
      console.error(
        `Payment element error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`
      );
    } else if (payMethods.card.gateway === "braintree") {
      if (!window.braintree) {
        await loadScript(
          "braintree-web",
          "https://js.braintreegateway.com/web/3.57.0/js/client.min.js"
        );
      }
    } else if (payMethods.card.gateway === "stripe") {
      if (!window.Stripe) {
        await loadScript("stripe-js", "https://js.stripe.com/v3/");
      }
      await stripeElements(request, payMethods, params);
    }
  }
  if (params.ideal) {
    if (!payMethods.card) {
      console.error(
        `Payment element error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`
      );
    } else if (!payMethods.ideal) {
      console.error(
        `Payment element error: iDEAL payments are disabled. See Payment settings in the Swell dashboard for details.`
      );
    } else if (payMethods.card.gateway === "stripe") {
      if (!window.Stripe) {
        await loadScript("stripe-js", "https://js.stripe.com/v3/");
      }
      await stripeElements(request, payMethods, params);
    }
  }
  if (params.paypal) {
    if (!payMethods.paypal) {
      console.error(
        `Payment element error: PayPal payments are disabled. See Payment settings in the Swell dashboard for details.`
      );
    } else if (payMethods.card && payMethods.card.gateway === "braintree" && payMethods.paypal.gateway === "braintree") {
      if (!window.paypal) {
        await loadScript(
          "paypal-sdk",
          `https://www.paypal.com/sdk/js?currency=${cart.currency}&client-id=${payMethods.paypal.client_id}&merchant-id=${payMethods.paypal.merchant_id}&vault=true`
        );
      }
      if (!window.braintree) {
        await loadScript(
          "braintree-web",
          "https://js.braintreegateway.com/web/3.57.0/js/client.min.js"
        );
      }
      if (window.braintree && !window.braintree.paypalCheckout) {
        await loadScript(
          "braintree-web-paypal-checkout",
          "https://js.braintreegateway.com/web/3.57.0/js/paypal-checkout.min.js"
        );
      }
      await braintreePayPalButton(request, cart, payMethods, params);
    } else {
      if (!window.paypal) {
        await loadScript(
          "paypal-sdk",
          `https://www.paypal.com/sdk/js?currency=${cart.currency}&client-id=${payMethods.paypal.client_id}&merchant-id=${payMethods.paypal.merchant_id}&intent=authorize&commit=false`
        );
      }
      await payPalButton(request, cart, payMethods, params);
    }
  }
}
const loadScript = async (id, src) => {
  LOADING_SCRIPTS[id] = LOADING_SCRIPTS[id] || new Promise((resolve) => {
    const script = document.createElement("script");
    script.id = id;
    script.src = src;
    script.async = true;
    script.type = "text/javascript";
    script.addEventListener(
      "load",
      () => {
        resolve();
        LOADING_SCRIPTS[id] = null;
      },
      {
        once: true
      }
    );
    document.head.appendChild(script);
  });
  return LOADING_SCRIPTS[id];
};
async function stripeElements(request, payMethods, params) {
  const { publishable_key } = payMethods.card;
  const stripe = window.Stripe(publishable_key);
  const elements = stripe.elements(params.config);
  const createElement = (type) => {
    const elementParams = get__default["default"](params, `card[${type}]`) || params.card || params.ideal;
    const elementOptions = elementParams.options || {};
    const element = elements.create(type, elementOptions);
    element.mount(elementParams.elementId || `#${type}-element`);
    elementParams.onChange && element.on("change", elementParams.onChange);
    elementParams.onReady && element.on("ready", elementParams.onReady);
    elementParams.onFocus && element.on("focus", elementParams.onFocus);
    elementParams.onBlur && element.on("blur", elementParams.onBlur);
    elementParams.onEscape && element.on("escape", elementParams.onEscape);
    elementParams.onClick && element.on("click", elementParams.onClick);
    if (type === "card" || type === "cardNumber" || type === "idealBank") {
      CARD_ELEMENTS.stripe = element;
    }
  };
  API.stripe = stripe;
  if (params.ideal) {
    createElement("idealBank");
  } else if (params.card.separateElements) {
    createElement("cardNumber");
    createElement("cardExpiry");
    createElement("cardCvc");
  } else {
    createElement("card");
  }
}
async function shouldUsePayPalEmail(guest, request, options2) {
  if (!guest)
    return false;
  const updatedCart = await methods$8(request, options2).get();
  const currentEmail = get__default["default"](updatedCart, "account.email");
  if (!currentEmail) {
    return true;
  } else {
    return false;
  }
}
async function payPalButton(request, cart, payMethods, params) {
  const paypal = window.paypal;
  const { paypal: { locale, style, elementId } = {} } = params;
  const { capture_total, currency, guest } = cart;
  const onError = (error) => {
    const errorHandler = get__default["default"](params, "paypal.onError");
    if (isFunction(errorHandler)) {
      return errorHandler(error);
    }
    throw new Error(error.message);
  };
  const onSuccess = () => {
    const successHandler = get__default["default"](params, "paypal.onSuccess");
    return isFunction(successHandler) && successHandler();
  };
  if (!(capture_total > 0)) {
    throw new Error(
      "Invalid PayPal button amount. Value should be greater than zero."
    );
  }
  paypal.Buttons(
    {
      locale: locale || "en_US",
      style: style || {
        layout: "horizontal",
        height: 45,
        color: "gold",
        shape: "rect",
        label: "paypal",
        tagline: false
      },
      createOrder: (data, actions) => actions.order.create({
        intent: "AUTHORIZE",
        purchase_units: [
          {
            amount: {
              value: +capture_total.toFixed(2),
              currency_code: currency
            }
          }
        ]
      }),
      onApprove: (data, actions) => actions.order.get().then(async (order) => {
        const orderId = order.id;
        const payer = order.payer;
        const shipping = get__default["default"](order, "purchase_units[0].shipping");
        const usePayPalEmail = await shouldUsePayPalEmail(
          guest,
          request,
          options$1
        );
        return methods$8(request).update(__spreadProps(__spreadValues$1({}, usePayPalEmail && {
          account: {
            email: payer.email_address
          }
        }), {
          billing: {
            method: "paypal",
            paypal: { order_id: orderId }
          },
          shipping: {
            name: shipping.name.full_name,
            address1: shipping.address.address_line_1,
            address2: shipping.address.address_line_2,
            state: shipping.address.admin_area_1,
            city: shipping.address.admin_area_2,
            zip: shipping.address.postal_code,
            country: shipping.address.country_code
          }
        }));
      }).then(onSuccess).catch(onError)
    },
    onError
  ).render(elementId || "#paypal-button");
}
async function braintreePayPalButton(request, cart, payMethods, params) {
  const authorization = await vaultRequest("post", "/authorization", {
    gateway: "braintree"
  });
  if (authorization.error) {
    throw new Error(authorization.error);
  }
  const braintree = window.braintree;
  const paypal = window.paypal;
  braintree.client.create({
    authorization
  }).then(
    (client) => braintree.paypalCheckout.create({
      client
    })
  ).then((paypalCheckoutInstance) => {
    return paypal.Buttons({
      style: params.paypal.style || {},
      createBillingAgreement: () => paypalCheckoutInstance.createPayment({
        flow: "vault",
        currency: cart.currency,
        amount: cart.grand_total
      }),
      onApprove: (data, actions) => paypalCheckoutInstance.tokenizePayment(data).then(
        ({ nonce }) => methods$8(request, options$1).update({
          billing: { paypal: { nonce } }
        })
      ).then(
        () => isFunction(params.paypal.onSuccess) && params.paypal.onSuccess(data, actions)
      ).catch(
        isFunction(params.paypal.onError) ? params.paypal.onError : (err) => console.error("PayPal error", err)
      ),
      onCancel: isFunction(params.paypal.onCancel) ? () => params.paypal.onCancel() : () => console.log("PayPal payment cancelled"),
      onError: isFunction(params.paypal.onError) ? (err) => params.paypal.onError(err) : (err) => console.error("PayPal error", err)
    }).render(params.paypal.elementId || "#paypal-button");
  }).catch(
    isFunction(params.paypal.onError) ? params.paypal.onError : (err) => console.error("PayPal error", err)
  );
}
async function paymentTokenize(request, params, payMethods, cart) {
  const { capture_total, auth_total } = cart;
  const onError = (error) => {
    const errorHandler = get__default["default"](params, "card.onError") || get__default["default"](params, "ideal.onError") || get__default["default"](params, "klarna.onError") || get__default["default"](params, "bancontact.onError") || get__default["default"](params, "paysafecard.onError");
    if (isFunction(errorHandler)) {
      return errorHandler(error);
    }
    throw new Error(error.message);
  };
  const onSuccess = (result) => {
    const successHandler = get__default["default"](params, "card.onSuccess") || get__default["default"](params, "ideal.onSuccess");
    if (isFunction(successHandler)) {
      return successHandler(result);
    }
  };
  if (!params) {
    return onError({ message: "Tokenization parameters not passed" });
  }
  if (params.card && payMethods.card) {
    if (payMethods.card.gateway === "stripe" && CARD_ELEMENTS.stripe && API.stripe) {
      const stripe = API.stripe;
      const paymentMethod = await createPaymentMethod(
        stripe,
        CARD_ELEMENTS.stripe,
        methods$2(request).authorizeGateway,
        cart
      ).catch(onError);
      if (!paymentMethod) {
        return;
      } else if (paymentMethod.error) {
        return onError(paymentMethod.error);
      } else if (capture_total < 1) {
        return methods$8(request, options$1).update({
          billing: {
            method: "card",
            card: paymentMethod
          }
        }).then(onSuccess).catch(onError);
      }
      const currency = toLower__default["default"](get__default["default"](cart, "currency", "usd"));
      const amount = stripeAmountByCurrency(
        currency,
        capture_total + auth_total
      );
      const stripeCustomer = get__default["default"](cart, "account.stripe_customer");
      const intent = toSnake(
        await methods$2(request).createIntent({
          gateway: "stripe",
          intent: __spreadValues$1({
            payment_method: paymentMethod.token,
            amount,
            currency,
            capture_method: "manual",
            off_session: true,
            confirm: true
          }, stripeCustomer ? { customer: stripeCustomer } : {})
        }).catch(onError)
      );
      if (intent && intent.status === "requires_confirmation") {
        const { paymentIntent, error } = await stripe.confirmCardPayment(
          intent.client_secret
        );
        return error ? onError(error) : await methods$8(request, options$1).update({
          billing: {
            method: "card",
            card: paymentMethod,
            intent: {
              stripe: __spreadValues$1({
                id: paymentIntent.id
              }, !!auth_total && {
                auth_amount: auth_total
              })
            }
          }
        }).then(onSuccess).catch(onError);
      }
    } else if (payMethods.card.gateway === "quickpay") {
      const intent = await createQuickpayPayment(
        cart,
        methods$2(request).createIntent
      ).catch(onError);
      if (!intent) {
        return;
      } else if (intent.error) {
        return onError(intent.error);
      }
      await methods$8(request, options$1).update({
        billing: {
          method: "card",
          intent: {
            quickpay: {
              id: intent
            }
          }
        }
      });
      createQuickpayCard(methods$2(request).authorizeGateway).catch(onError);
    }
  } else if (params.ideal && payMethods.ideal) {
    if (payMethods.card && payMethods.card.gateway === "stripe" && CARD_ELEMENTS.stripe && API.stripe) {
      const { error, paymentMethod } = await createIDealPaymentMethod(
        API.stripe,
        CARD_ELEMENTS.stripe,
        cart
      );
      if (error) {
        return onError(error);
      }
      const currency = toLower__default["default"](get__default["default"](cart, "currency", "eur"));
      const amount = stripeAmountByCurrency(currency, capture_total);
      const intent = toSnake(
        await methods$2(request).createIntent({
          gateway: "stripe",
          intent: {
            payment_method: paymentMethod.id,
            amount,
            currency,
            payment_method_types: "ideal",
            confirmation_method: "manual",
            confirm: true,
            return_url: window.location.href
          }
        }).catch(onError)
      );
      if (intent) {
        await methods$8(request, options$1).update({
          billing: {
            method: "ideal",
            ideal: {
              token: paymentMethod.id
            },
            intent: { stripe: { id: intent.id } }
          }
        }).catch(onError);
        return (intent.status === "requires_action" || intent.status === "requires_source_action") && await API.stripe.handleCardAction(intent.client_secret);
      }
    }
  } else if (params.klarna && payMethods.klarna) {
    if (payMethods.klarna.gateway === "klarna") {
      const session = await createKlarnaSession(
        cart,
        methods$2(request).createIntent
      ).catch(onError);
      return session && window.location.replace(session.redirect_url);
    } else if (payMethods.card && payMethods.card.gateway === "stripe") {
      if (!window.Stripe) {
        await loadScript("stripe-js", "https://js.stripe.com/v3/");
      }
      const { publishable_key } = payMethods.card;
      const stripe = window.Stripe(publishable_key);
      const settings = toSnake(await methods$3(request, options$1).get());
      const { error, source } = await createKlarnaSource(stripe, __spreadProps(__spreadValues$1({}, cart), {
        settings: settings.store
      }));
      return error ? onError(error) : methods$8(request, options$1).update({
        billing: {
          method: "klarna"
        }
      }).then(() => window.location.replace(source.redirect.url)).catch(onError);
    }
  } else if (params.bancontact && payMethods.bancontact) {
    if (payMethods.card && payMethods.card.gateway === "stripe") {
      if (!window.Stripe) {
        await loadScript("stripe-js", "https://js.stripe.com/v3/");
      }
      const { publishable_key } = payMethods.card;
      const stripe = window.Stripe(publishable_key);
      const { error, source } = await createBancontactSource(stripe, cart);
      return error ? onError(error) : methods$8(request, options$1).update({
        billing: {
          method: "bancontact"
        }
      }).then(() => window.location.replace(source.redirect.url)).catch(onError);
    }
  } else if (params.paysafecard && payMethods.paysafecard) {
    const intent = await createPaysafecardPayment(
      cart,
      methods$2(request).createIntent
    ).catch(onError);
    if (!intent) {
      return;
    }
    await methods$8(request, options$1).update({
      billing: {
        method: "paysafecard",
        intent: {
          paysafecard: {
            id: intent.id
          }
        }
      }
    });
    return window.location.replace(intent.redirect.auth_url);
  }
}
async function handleRedirect(request, params, cart) {
  const onError = (error) => {
    const errorHandler = get__default["default"](params, "card.onError") || get__default["default"](params, "paysafecard.onError") || get__default["default"](params, "klarna.onError");
    if (isFunction(errorHandler)) {
      return errorHandler(error);
    }
    throw new Error(error.message);
  };
  const onSuccess = (result2) => {
    const successHandler = get__default["default"](params, "card.onSuccess") || get__default["default"](params, "paysafecard.onSuccess") || get__default["default"](params, "klarna.onSuccess");
    if (isFunction(successHandler)) {
      return successHandler(result2);
    }
  };
  const queryParams = getLocationParams(window.location);
  removeUrlParams();
  const { gateway } = queryParams;
  let result;
  if (gateway === "quickpay") {
    result = await handleQuickpayRedirectAction(
      request,
      cart,
      params,
      queryParams
    );
  } else if (gateway === "paysafecard") {
    result = await handlePaysafecardRedirectAction(
      request,
      cart);
  } else if (gateway === "klarna_direct") {
    result = await handleDirectKlarnaRedirectAction(
      request,
      cart,
      params,
      queryParams
    );
  }
  if (!result) {
    return;
  } else if (result.error) {
    return onError(result.error);
  } else {
    return onSuccess(result);
  }
}
async function handleQuickpayRedirectAction(request, cart, params, queryParams) {
  const { redirect_status: status, card_id: id } = queryParams;
  switch (status) {
    case "succeeded":
      const card = await getQuickpayCardDetais(
        id,
        methods$2(request).authorizeGateway
      );
      if (!card) {
        return;
      } else if (card.error) {
        return card;
      } else {
        await methods$8(request, options$1).update({
          billing: {
            method: "card",
            card
          }
        });
        return { success: true };
      }
    case "canceled":
      return {
        error: {
          message: "We are unable to authenticate your payment method. Please choose a different payment method and try again."
        }
      };
    default:
      return { error: { message: `Unknown redirect status: ${status}.` } };
  }
}
async function handlePaysafecardRedirectAction(request, cart) {
  const paymentId = get__default["default"](cart, "billing.intent.paysafecard.id");
  if (!paymentId) {
    return {
      error: {
        message: "Paysafecard payment ID not defined."
      }
    };
  }
  const intent = await methods$2(request).updateIntent({
    gateway: "paysafecard",
    intent: { payment_id: paymentId }
  });
  if (!intent) {
    return;
  }
  switch (intent.status) {
    case "AUTHORIZED":
      return { success: true };
    case "CANCELED_CUSTOMER":
      return {
        error: {
          message: "We are unable to authenticate your payment method. Please choose a different payment method and try again."
        }
      };
    default:
      return {
        error: { message: `Unknown redirect status: ${intent.status}.` }
      };
  }
}
async function handleDirectKlarnaRedirectAction(request, cart, params, queryParams) {
  const { authorization_token } = queryParams;
  if (!authorization_token) {
    return {
      error: {
        message: "We are unable to authenticate your payment method. Please choose a different payment method and try again."
      }
    };
  }
  await methods$8(request, options$1).update({
    billing: {
      method: "klarna",
      klarna: {
        token: authorization_token
      }
    }
  });
  return { success: true };
}
async function authenticate(request, payment, payMethods) {
  const { method, gateway } = payment;
  if (method === "card") {
    const cardMethod = payMethods.card;
    if (!cardMethod) {
      console.error(
        `Authenticate error: credit card payments are disabled. See Payment settings in the Swell dashboard for details.`
      );
    } else if (gateway === "stripe" && cardMethod.gateway === "stripe") {
      if (!window.Stripe) {
        await loadScript("stripe-js", "https://js.stripe.com/v3/");
      }
      return authenticateStripeCard(request, payment, payMethods);
    }
  }
}
async function authenticateStripeCard(request, payment, payMethods) {
  const { transaction_id: id, card: { token } = {} } = payment;
  const { publishable_key } = payMethods.card;
  const intent = await methods$2(request, options$1).updateIntent({
    gateway: "stripe",
    intent: { id, payment_method: token }
  }).catch((error) => ({
    error
  }));
  if (intent.error) {
    return intent;
  }
  const stripe = window.Stripe(publishable_key);
  const actionResult = await stripe.confirmCardPayment(intent.client_secret);
  return actionResult.error ? {
    error: {
      message: actionResult.error.message,
      code: actionResult.error.code
    }
  } : { status: actionResult.status };
}

function methods$1(request, opt) {
  return {
    code: null,
    state: null,
    list() {
      return opt.api.settings.get("store.locales", []);
    },
    async select(locale) {
      this.set(locale);
      setCookie("swell-locale", locale);
      opt.api.settings.locale = locale;
      return await request("put", "/session", { locale });
    },
    selected() {
      if (this.code) {
        return this.code;
      }
      const storeLocale = opt.api.settings.getStoreLocale();
      const cookieLocale = getCookie("swell-locale");
      opt.api.settings.locale = cookieLocale || storeLocale;
      return cookieLocale || storeLocale;
    },
    get() {
      if (!this.code) {
        this.code = this.selected();
      }
      if (!this.state) {
        this.state = this.set(this.code);
      }
      return this.state;
    },
    set(code) {
      this.code = code;
      this.state = find__default["default"](this.list(), { code }) || {};
      return this.state;
    }
  };
}

const FORMATTERS = {};
function methods(request, opt) {
  return {
    code: null,
    state: null,
    locale: null,
    list() {
      return opt.api.settings.get("store.currencies", []);
    },
    async select(currency) {
      this.set(currency);
      return request("put", "/session", { currency });
    },
    selected() {
      if (!this.code) {
        this.set(
          getCookie("swell-currency") || opt.api.settings.get("store.currency")
        );
      }
      return this.code;
    },
    get() {
      if (!this.code) {
        this.code = this.selected();
      }
      if (!this.state) {
        this.state = this.set(this.code);
      }
      return this.state;
    },
    set(code = "USD") {
      this.code = code;
      this.state = find__default["default"](this.list(), { code }) || { code };
      this.locale = String(
        opt.api.settings.get(
          "store.locale",
          typeof navigator === "object" ? navigator.language : "en-US"
        )
      );
      setCookie("swell-currency", code);
      return this.state;
    },
    format(amount, params = {}) {
      let state = this.get();
      if (params.code && params.code !== state.code) {
        const list = this.list();
        state = find__default["default"](list, { code: params.code }) || { code: params.code };
      }
      const { code = "USD", type, decimals, rate } = state;
      const formatCode = params.code || code;
      const formatRate = params.rate || rate;
      const formatLocale = params.locale || this.locale;
      const formatDecimals = typeof params.decimals === "number" ? params.decimals : decimals;
      const { convert = true } = params;
      let formatAmount = amount;
      if (convert && (type === "display" || params.rate) && typeof formatAmount === "number" && typeof formatRate === "number") {
        formatAmount = this.applyRounding(amount * formatRate, state);
      }
      const formatter = this.formatter({
        code: formatCode,
        locale: formatLocale,
        decimals: formatDecimals
      });
      try {
        if (typeof formatAmount === "number") {
          return formatter.format(formatAmount);
        } else {
          const symbol = get__default["default"](formatter.formatToParts(0), "0.value", "$");
          return symbol !== formatCode ? symbol : "";
        }
      } catch (err) {
        console.warn(err);
      }
      return String(amount);
    },
    formatter({ code, locale, decimals }) {
      locale = String(locale || "").replace("_", "-");
      const key = [code, locale, decimals].join("|");
      if (FORMATTERS[key]) {
        return FORMATTERS[key];
      }
      const formatLocales = [];
      if (locale) {
        formatLocales.push(locale);
      }
      formatLocales.push("en-US");
      const formatDecimals = typeof decimals === "number" ? decimals : void 0;
      const props = {
        style: "currency",
        currency: code,
        currencyDisplay: "symbol",
        minimumFractionDigits: formatDecimals,
        maximumFractionDigits: formatDecimals
      };
      try {
        try {
          FORMATTERS[key] = new Intl.NumberFormat(formatLocales, props);
        } catch (err) {
          if (err.message.indexOf("Invalid language tag") >= 0) {
            FORMATTERS[key] = new Intl.NumberFormat("en-US", props);
          }
        }
      } catch (err) {
        console.warn(err);
      }
      return FORMATTERS[key];
    },
    applyRounding(value, config) {
      if (!config || !config.round) {
        return value;
      }
      const scale = config.decimals;
      const fraction = config.round_interval === "fraction" ? config.round_fraction || 0 : 0;
      let roundValue = ~~value;
      let decimalValue = this.round(value, scale);
      if (decimalValue === fraction) {
        return roundValue + decimalValue;
      }
      const diff = this.round(decimalValue - fraction, 1);
      const direction = config.round === "nearest" ? diff > 0 ? diff >= 0.5 ? "up" : "down" : diff <= -0.5 ? "down" : "up" : config.round;
      switch (direction) {
        case "down":
          roundValue = roundValue + fraction - (decimalValue > fraction ? 0 : 1);
          break;
        case "up":
        default:
          roundValue = roundValue + fraction + (decimalValue > fraction ? 1 : 0);
          break;
      }
      return this.round(roundValue, scale);
    },
    round: round__default["default"]
  };
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const options = {
  store: null,
  key: null,
  url: null,
  useCamelCase: null,
  previewContent: null
};
const api = {
  version: "3.18.0",
  options,
  request,
  init(store, key, opt = {}) {
    options.key = key;
    options.store = store;
    options.url = opt.url ? trimEnd(opt.url) : `https://${store}.swell.store`;
    options.vaultUrl = opt.vaultUrl ? trimEnd(opt.vaultUrl) : `https://vault.schema.io`;
    options.timeout = opt.timeout && parseInt(opt.timeout, 10) || 2e4;
    options.useCamelCase = opt.useCamelCase || false;
    options.previewContent = opt.previewContent || false;
    options.session = opt.session;
    options.locale = opt.locale;
    options.currency = opt.currency;
    options.api = api;
    setOptions(options);
  },
  auth(...args) {
    return this.init(...args);
  },
  get(url, query) {
    return request("get", url, query);
  },
  put(url, data) {
    return request("put", url, data);
  },
  post(url, data) {
    return request("post", url, data);
  },
  delete(url, data) {
    return request("delete", url, data);
  },
  cache: cacheApi,
  card: cardApi,
  cart: methods$8(request, options),
  account: methods$7(request),
  products: methods$9(request, options),
  categories: methods$6(request),
  attributes: methods$a(request),
  subscriptions: methods$5(request),
  content: methods$4(request, options),
  settings: methods$3(request, options),
  payment: methods$2(request, options),
  locale: methods$1(request, options),
  currency: methods(request, options),
  utils
};
async function request(method, url, id = void 0, data = void 0, opt = void 0) {
  const allOptions = __spreadValues(__spreadValues({}, options), opt);
  const session = allOptions.session || getCookie("swell-session");
  const locale2 = allOptions.locale || getCookie("swell-locale");
  const currency2 = allOptions.currency || getCookie("swell-currency");
  const baseUrl = `${allOptions.url}${allOptions.base || ""}/api`;
  const reqMethod = String(method).toLowerCase();
  let reqUrl = url;
  let reqData = id;
  if (data !== void 0 || typeof id === "string") {
    reqUrl = [trimEnd(url), trimStart(id)].join("/");
    reqData = data;
  }
  reqUrl = allOptions.fullUrl || `${baseUrl}/${trimBoth(reqUrl)}`;
  reqData = allOptions.useCamelCase ? toSnake(reqData) : reqData;
  let reqBody;
  if (reqMethod === "get") {
    let exQuery;
    [reqUrl, exQuery] = reqUrl.split("?");
    const fullQuery = [exQuery, stringifyQuery(reqData)].join("&").replace(/^&/, "");
    reqUrl = `${reqUrl}${fullQuery ? `?${fullQuery}` : ""}`;
  } else {
    reqBody = JSON.stringify(reqData);
  }
  const reqHeaders = {
    Accept: "application/json",
    "Content-Type": "application/json",
    Authorization: `Basic ${base64Encode(String(allOptions.key))}`
  };
  if (session) {
    reqHeaders["X-Session"] = session;
  }
  if (locale2) {
    reqHeaders["X-Locale"] = locale2;
  }
  if (currency2) {
    reqHeaders["X-Currency"] = currency2;
  }
  const response = await fetch(reqUrl, {
    method: reqMethod,
    headers: reqHeaders,
    body: reqBody,
    credentials: "include",
    mode: "cors"
  });
  const responseSession = response.headers.get("X-Session");
  if (typeof responseSession === "string" && session !== responseSession) {
    setCookie("swell-session", responseSession);
  }
  const result = await response.json();
  if (result && result.error) {
    const err = new Error(result.error.message);
    err.status = response.status;
    err.code = result.error.code;
    err.param = result.error.param;
    throw err;
  } else if (!response.ok) {
    const err = new Error(
      "A connection error occurred while making the request"
    );
    err.code = "connection_error";
    throw err;
  }
  return options.useCamelCase ? toCamel(result) : result;
}

module.exports = api;
//# sourceMappingURL=swell.cjs.min.js.map
